== リンク層の技術
=== 隣接デバイスとの無線通信

コントローラの機能は、隣接するデバイスとの通信です。 Bluetooth low energy のコントローラは、電波を送受信する物理層、隣接するデバイスとの接続とパケット通信を管理するリンク・レイヤ、そしてホストのインタフェースHCIで構成されます。 Bluetooth low energy の物理層の特性を <<table-ble-phy-specification>> に示します。

[[table-ble-phy-specification]]
.Bluetooth low energyの物理層の特性
[options="header"]
|===
|項目              | 値
|周波数             |   2.400-2.4835 GHz
|物理層のビットレート | 1 Mbps
|通信送信電力        | 10 ミリワット ~ 10 マイクロワット
|伝達距離           |  50メートル (見通し)
|===

==== 周波数帯

Bluetooth low energy が利用する周波数は、クラシックBluetoothと同じ2.4GHz帯を使います。周波数帯が同じなので、クラシックBluetoothと Bluetooth low energy を両方搭載したものでも、同じアンテナや高周波回路を使えます。

この2.4GHz帯は、ISM (Industry-Science-Medical、アイエスエム) バンドと呼ばれるいくつかある周波数帯の1つです。ISMバンドは、産業、科学、医療、という名称が示すように、もともとは無線通信以外の産業・科学・医療に高周波エネルギー源として利用するために指定された周波数帯です。身近なものでは、電子レンジは加熱に2.45GHzの周波数を使います。

電波は公共の資源ですから、その周波数は区分されて利用目的が定められています。ですから、新しい無線機器を普及させて一般で使うには、周波数区分という資源の割り当てが必要です。また、国際展開のために、それが国際的に認められて各国が受け入れることも必要です。

新しい周波数区分の割り当ては、大変な手間と時間がかかります。そのため、Bluetoothに限らず無線LANなどの空中線電力の小さい高度な通信装置には、2.4GHz帯をはじめとするISMバンドの利用を認めてきました。

Bluetoothが利用する周波数帯はBluetooth専用ではありません。無線LANをはじめとする様々な通信装置や電子レンジも利用していますから、他の機器からの混信が常に生じうる、賑やかな周波数帯です。

Bluetooth low energy は、同じ周波数帯を利用する無線機器があることを前提に設計されています。混信を与えないように、また通信が頻繁に切断しないように、80MHzの周波数帯を2MHz幅に分割したチャネルと、適応周波数ホッピング方式を導入しています。

==== 変調方式

情報を送るために電波の波形を変化させることを変調と言います。変調は、送信する電波、情報を搬送する波なので搬送波と呼びます、の波の大きさ(振幅)または周波数および位相を時間変化させることです。この変調は0/1のデジタルデータを、四方八方に広がっていく電波にのせる技術です。

Bluetooth low energy の変調方式は、Gaussian Frequency Shift Keying (ガウシアン周波数シフトキーイング、GFSK) という連続位相周波数偏移変調方式の1つです。周波数シフトキーイングは、0/1のビット・データごとに、一定の周期で周波数の遷移(シフト)量を切り替える(キーイング)変調方式です。

250kHzの周波数偏移では、1マイクロ秒後に搬送波の位相が90度変化します。250kHzの周期は4マイクロ秒ですから、1マイクロ秒は1/4周期だからです。搬送波に比べればごく僅かな周波数遷移ですが、1マイクロ秒後たてば振幅の符号が正負に分かれるため、容易に情報を取り出せます。この1つの信号をシンボルと呼びます。 Bluetooth low energy のシンボル・レートは1Mbpsです。1シンボルは、振幅が正負どちらかにわかれる2状態なので、1シンボルで1ビットが伝送できます。ですからビット・レートは1Mbpsになります。

GFSKのガウシアンは、0/1の信号をガウスフィルタを通して滑らかにした波形で、周波数遷移をおこなうことから名づけられています。0/1の変化そのままで周波数遷移をすると、0/1の変化点で搬送波が急激に変化して、周波数占有幅が大きくなります。これは周波数帯域を効率よく使うための技術です。

物理層のビットレートは将来引き上げられるかもしれません。しかし、 Bluetooth low energy では、ビットレートの向上は、より速い通信ではなく、さらなる低消費電力のためです。例えば、ビットレートが現在の1Mbpsから2倍の2Mbpsになれば、送受信回路の稼働時間が半分になります。半導体素子の電力の大部分が2.4GHzの高周波信号を送受信する回路で消費されますから、これは電池の稼働時間を大きく伸ばします。

==== チャンネル

電波での無線通信は、送信側と受信側がいること、それらが同じ時間に周波数を使っていること、で成り立ちます。また電波は四方八方に広がるので、自分たちの通信が他の通信の混信を引き起こしたり、逆に混信をうけます。

Bluetooth low energy は、心拍センサや時計などの一般に普及する身に付けるデバイスで利用されます。そのために、公共の場所など、自分とその周囲の人たちが持つデバイスをあわせると、100や1000のデバイスが同時に通信をしている場面も生じます。さらに、 Bluetooth low energy を搭載するようなモバイル機器は無線LANも搭載しています。それらの無線通信との共存も必要です。

Bluetooth low energy は、2.400 GHzから2.480GHzまでの80MHzの帯域を、2MHz幅で分割して、40のチャンネルとします。送信側と受信側が同じチャネルを使っていれば、同じ周波数をつかうことになります。また、あるチャンネルの通信は、周波数が十分離れていますから、隣接するチャンネルまたその他のチャンネルの通信に影響しません。ですから、違うチャンネルを利用すれば、複数の機器が同時に通信をしていても混信が生じません。

40のチャンネルには、それぞれ0から39までの番号が割り振られます。チャンネルは2種類にわけられます。チャンネル37からチャンネル39までの3チャンネルをアドバタイジング・チャンネル、チャンネル0からチャンネル36までの37チャンネルをデータ・チャンネルと呼びます。

アドバタイジング・チャンネルは、デバイスの発見と接続に使います。データ・チャンネルは、接続が完了したデバイス同士の通信に使います。アドバタイジング・チャンネルは、3つのうちどれか1つのチャンネルで通信ができるならば、機能します。データ・チャンネルは、適応周波数ホッピング方式と呼ばれる、通信につかうチャンネルを時間で次々に切り替えていく方式をつかうので、一部のチャンネルで混信をうけても通信は断絶しません。

Bluetooth low energy を搭載するモバイル機器は、たいてい無線LANを搭載しています。そして、まずはデバイスを発見できなければ、通信がはじまりません。そのため、デバイスの発見に使うアドバタイジング・チャンネルには、無線LANと混信しにくいチャンネルが、3つ割り当てられています。

無線LANは、1チャンネルあたりの帯域が20MHz、14のチャネルを、5MHzづつずらして、隣接するチャンネルと帯域を重ねて配置されています。無線LANでよく使われるチャンネルは、1、6，および11で、それぞれの中心周波数は2.412 GHz、2.437 GHz、および2.462 GHzです。

これに Bluetooth low energy のチャンネルを重ねると(TBD 図 チャンネル)になります。
無線LANにかぎらず任意の無線通信の混信を避けるには、2．4GHzの帯域内の、なるべく離れたチャンネルを使うしかありません。チャンネル37 (2.402 GHz)とチャンネル39 (2.426 GHz)は、帯域の端に割り当ててあります。もう1つのチャンネル38 (2.480 GHz)は、帯域のなるべく中央で、かつ無線LANのチャンネルと重ならないものが選ばれています。

アドバタイジング・チャンネルの数が3よりも多ければ、より混信を避けられそうです。しかしそうすると、非接続時の周辺機器の電池消費量が、チャネル数分だけ増えてしまいます。周辺機器は、自分の存在を周囲に伝えるために、アドバタイズメント・パケットを送信します。アドバタイズメント・パケットは、一定の周期ごとに、3チャネルそれぞれで送信します。ですから、もしもアドバタイジング・チャネルを、2倍の6チャネルにすると、非接続時の周辺機器の電池消費量も単純に2倍になるでしょう。

==== パケット・フォーマット

通信でつかわれる、制御情報とデータを含む連続したビットのかたまりを、パケットと呼びます。 Bluetooth low energy のパケットのフォーマットは [#fig_ble_packet_format] です。オクテットは8ビットの情報を表す単位です。通常使うバイトと同じ意味ですが、機種によっては8ビットではないバイトもありうるのです。そのため、通信では、曖昧さがない8を表すオクテットを使います。

![ #fig_ble_packet_format パケット・フォーマット](fig/ch02_ble_packet_format.png)

パケットは、アクセス・アドレス、上位階層が送受信するデータであるプロトコル・データ・ユニット(Protocol Data Unit, PDU)とその誤り検出用の巡回検査符号(Cyclic Reundancy Check, CRC)の3つのエンティティで、構成されます。

パケットの長さは、80から376ビット(10 ~ 47オクテット)、ビット・レートが1Mbpsなので、80から376マイクロ秒の範囲になります。マイクロ(ギリシャ文字 μ と表記します)は10<sup>-6</sup>を示す接尾語です。1 / 1Mbpsで1マイクロ秒です。 Bluetooth low energy は、センサ値など少量のデータを決まったタイミングで通信するものなので、この最大376マイクロ秒の短いパケットのみで、通信がおこなわれます。

パケットは、エンティティごとに最下位ビットから最上位ビットの順に送出されます。バイトオーダは、リンクレイヤではなく、上位プロトコルによります。アドバタイジング・パケットは、最上位バイトから最下位バイトの順(ビッグエンディアン)に送出されます。デバイスとデータをやり取りするのに使うGATTプロファイルは、最下位バイトから最上位バイトの順(リトルエンディアン)に送出します。PDUを直接読み書きするときは、このネットワーク・バイトオーダーに注意します。

パケットの先頭のプリアンブルは、信号の強さと0/1のビットを読み取るタイミングの検出に使われます。

プリアンブルは、0/1が交互に続く8ビットの値 10101010b または 01010101b (接尾語 b は2進数表記を示す)です。2つの値のうち、末尾のビットが続くアクセス・アドレスの先頭ビットと異なるもの、境界に同じビット00bまたは11bが連続しないもの、が送出されます。

Bluetooth low energy は、受信回路のダイナミック・レンジ(受信可能な最大の信号と最小信号の比)が80dBあります。つまり受信電力で8桁、電圧で4桁の範囲の信号を受信します。このダイナミック・レンジは、受信信号が信号の強さに応じて増幅率を自動で調整することで、実現されます。もしもプリアンブルがなければ、増幅率を調整している間に、データを含む信号が来てしまい、取りこぼしてしまいます。

プリアンブルは、信号の読み出しタイミングの同期に必要です。変調信号の0/1の変化し終わったタイミングがわかれば、シンボル・レートが1Mbpsとわかっているので、あとは1マイクロ秒ごとに値を読み出すだけです。プリアンブルの0/1を繰り返す波形で、読み出しタイミングを同期します。

アクセス・アドレスは、2つのデバイス間で接続ごとに割り振られるランダムな値です。アクセス・アドレスは、そのパケットがどの接続のものかを区別する識別子で、物理インタフェースとは無関係のランダムな値です。イーサネットにあるような、物理インタフェースに割り振られた唯一の固定のアドレスではありません。

アクセス・アドレスは32ビットありますが、実際に利用できるアドレスは31ビット分です。ですからピコネットの最大同時接続数は、アドレス数の制約からは、2<sup>31</sup>になります。31ビットに制約されるのは、周波数変調信号の復調回路に、受信信号から自分の周波数のずれを自動調整する機能があるからです。000...0bや111...1bのように同じ値が連続すると、同じ周波数がずっと受信されます。すると、この自動調整機能の働きで、復調の基準とする周波数がずれていき、ただしい復調ができなくなります。これを避けるために、アクセス・アドレスは、32ビットの任意の6ビットをとりだしたとき、うち2ビットで0/1が変化している値を使います。

プロトコル・データ・ユニット(Protocol Data Unit, PDU)が、パケットが運ぶデータです。2オクテットから39オクテットの長さがあります。もしもPDUに連続する0/1があると、アクセス・アドレスとおなじ不都合が生じます。それを避けるために、PDUにはホワイトニングという、0/1を適当に変化させる変換処理がおこなわれます。これは送受信回路内部で処理されるので、アプリケーション側からは見えません。

CRC(Cyclic Redundancy Check, CRC)は、PDUのエラー検出のための巡回検査符号です。2および4ビットまたは奇数個のエラービットがあるとき、誤りだと検出できます。つまり、1,2,3,4,5,7,9... つのビット・エラーを検出できます。より強力な誤り検出が必要なときは、PDUの暗号化を使います。PDUが正しく暗号化されているかをチェックするためのメッセージ・インテグリティ・チェック(Message Integrity Check, MIC)が追加されます。

=== 発見と接続

リンク層は、電波が届く範囲にある隣接デバイスの発見と、発見したデバイスとの接続および双方向通信を提供します。これらの仕組みと処理の流れを、通信制御の仕組み、やりとりするPDUのフォーマット、そしてパケットの送受信の手順とタイミング、の3点から述べます。

==== デバイスの発見とピコネットへの参加

![ #fig_link_layer_state_machine リンク層の状態遷移](fig/ch02_ble_link_layer_state_machine.png)

デバイスの発見と接続の流れは、リンク層の状態遷移図を使うとわかりやすくなります。リンク層には5つの状態:

- スタンドバイ(Standby)
- アドバタイジング(Acvertising)
- スキャニング(Scanning)
- イニシエーティング(Initiating)
- コネクション(Connection)

があります。スキャニングには、パッシブ・スキャン(Passive Scan)とアクティブ・スキャン(Active Scan)またコネクションには、マスター(Master)とスレーブ(Slave)のサブステートがあります。

スマートフォンが周辺機器に接続するまでの、状態遷移を見てみます。周辺機器がアドバタイジング・パケットを送信して、スマートフォンがそれを受信してデバイスを発見、そして接続をします。この時、スマートフォンの働きをするものをスキャナ(Scanner)、周辺機器の働きをするものをアドバタイザ(Advertiser)と呼びます。

スキャナとアドバタイザのリンク層は、どちらも最初はスタンドバイ状態にあります。スタンドバイ状態は、送受信を何もしません。

アドバタイザはアドバタイジング状態に遷移して、一定期間ごとにアドバタイジング・パケットを送信します。

スキャナはスキャニング状態に遷移してアドバタイジング・パケットを受信します。アドバタイジング・パケットを受信するだけなのが、パッシブ・スキャンです。アクティブ・スキャンは、アドバタイジング・パケットを受信したあとに、アドバタイザにリクエストを送り、さらなる情報を取得します。

スマートフォンがスキャンして得た情報から、接続先を決めます。スマートフォンはイニシエイティング状態に遷移します。この時のスマートフォンの役割をイニシエータと呼びます。イニシエータは、接続したいアドバタイザからのアドバタイジング・パケットを受信したあとに、接続要求を送信して、コネクション状態に遷移します。

ピコネットは、1つのマスターに複数のスレーブが接続するスター型のネットワークです。スレーブ同士が通信することはありません。接続が完了すると、イニシエータはマスター、アドバタイザはスレーブの役割になります。

状態遷移の経路から、スレーブには以下の制約があります:

1. 同時にマスターかつスレーブには、なれない。
2. スレーブは同時に2つ以上のマスターと接続しない。

スキャナやアドバタイザといった役割は、リンク層の制御機能で作られます。ですから、たいていの Bluetooth low energy の半導体では、ソフトウェアでどの役割をもたせるかが決められます。スマートフォンがアドバタイザになることも、また周辺機器がマスターでスマートフォンがスレーブになるピコネットを作ることもできます。

また、1つのコントローラが同時にスレーブかつマスターになることはできません。コネクション状態に遷移したスレイブはアドバタイジング・パケットを送出しませんから、スレーブは同時に2つ以上のマスターとは接続しません。スレーブは、かならず1つのピコネットに属します。

==== アドバタイジング・パケット

デバイスの発見のためにアドバタイザが送信するパケットが、アドバタイジング・パケットです。

周波数帯域は、チャネル37, 38, 39、の3チャネルを使います。デバイスが確実に発見されるように、3つのチャネルをすべて使うことが推奨されます。アドバタイジングに使うチャネルは、アドバタイザのファームウェアから設定できます。デバックで無線通信を傍受(スニッフィング)するときは、スニッフィングをしやすくするために、チャンネルをどれか1つに限定することがあります。

アドバタイジングでの通信は、非接続の同報通信です。リンク層のアクセス・アドレスは、固定値 10001110100010011011111011010110b (0x8E89BED6) が使われます。

![ #fig_advertising_timing アドバタイジング・イベントのタイミング](fig/ch02_advertising_timing.png)

アドバタイジング・パケットは、一定周期のアドバタイジング・イベントごとに送出されます( [#fig_advertising_timing] ) 。アドバタイジング・イベントごとに、アドバタイジング・パケット(ADV_IND と表記している)が、チャンネルごとに送出されます。チャンネルごとのパケット送出時間は10ミリ秒以下です。

イベントの周期 T_advEvent は:

$$T_advEvent = advInterval + advDelay$$

と表されます。

advIntervalはアドバタイジングの周期です。20ミリ秒から10.24秒までの、0.625ミリ秒の整数倍の値を設定します。advIntervalが短いほど、デバイスは発見されやすくなりますが、電波を送信する分、電池の消費量が大きくなります。この値設定は、アドバタイザのファームウェア設計次第です。例えば、電源を入れて30秒間は、ユーザが接続をしようとしているだろうから20ミリ秒で、接続されないままならば、その後は徐々に周期を長くして、デバイス発見に少し時間はかかるが電池消費量は抑える、処理にします。

advDelayは0から10ミリ秒のランダムな値です。もしも、全く同じ開始タイミングで同じ周期のアドバタイジングをしているデバイスが2つあると混信しつづけます。そのような状況を避けるために、アドバタイジング・イベントをランダムにずらしています。

===== スキャン

アドバタイジング・パケットのペイロードは37オクテットの情報を送れます。しかしアドバタイザの情報は、たいてい、このペイロードだけでは不足します。アドバタイザからより多くのデバイス情報を引き出すのが、スキャンです。

スキャニングには、パッシブ・スキャンとアクティブ・スキャンがあります。パッシブ・スキャンはアドバタイザのパケットを受信するだけのスキャンです。アクティブ・スキャンは、アドバタイジング・パケットの終了から150マイクロ秒後に、SCAN_REQパケットを送信します。スキャン・リクエスト(SCAN\_REQ)パケットを受信したアドバタイザは、アドバタイジング・パケットと同じ37オクテットのペイロードがあるスキャン・レスポンス(SCAN\_RES)パケットを、150マイクロ秒後に返します。

アドバタイジング・パケットとSCAN\_RESパケットは同じデータフォーマットに従います。ここで、アクティブ・スキャンは、パケットをやり取りする分だけ電力を消費します。そこでSCAN\_RESパケットは、時間で変化しない情報を納めるものとします。スキャナが読み取ったSCAN\_RESパケットをキャッシュすることで、スキャンは1度だけですむようにします。SCAN\_RESパケットには、アドバタイザが持っている機能を表すサービスの識別子やデバイスの名称などが置かれます。

アドバタイザの周囲には複数のスキャナがいるときに、いくつかのスキャナが同時にSCAN\_REQパケットを送信すると、パケットが衝突して、アドバタイザはパケットを正しく受信できなくなります。スキャナは、レスポンスが返ってこないときは、SCAN\_RESパケットの送信を、ランダムな回数で間引いていきます。

===== ペイロードのフォーマット

アドバタイジング・パケットのPDUは、2オクテットのヘッダと6〜37オクテットのペイロードがあります。このヘッダの、PDU TypeはPDUの種類を示します。TxAdd, RxAddはPDU Typeにより異なる意味を持ちます。Lengthはペイロードの長さをオクテット単位で示します。

.PDUタイプ
[[table-pdu-type]]
[options="header"]
|===
|PDUタイプ | 役割                                    | 略語          |
|b3b2b1b0 |                                        |               |
|0000     | Connectable undirected advertising     | ADV_IND       |
|0001     | Connectable directed advertising       | ADV\_DIRECT_IND    |
|0010     | Non connectable undirected advertising | ADV\_NONCONN_IND   |
|0011     | Scan request                           | SCAN_REQ           |
|0100     | Scan response                          | SCAN_RSP           |
|0101     | Connection request                     | CONNECT_REQ        |
|0110     | Scannable undirected advertising       | ADV\_SCAN_IND      |
|===

ヘッダのPDU Typeは7タイプあります ( <<table-pdu-type>> )。このうち、アドバタイジングにつかうのは4タイプです。PDUタイプは、わかりやすく、短い略語であらわします。役割にあるConnectableは、接続要求ができることを、undirectedは不特定多数のデバイスへのアドバタイジング、directedは特定デバイスへのアドバタイジング、またScannnableは、のちに述べるスキャン要求ができること、を示しています。

.PDUタイプと接続可能性
[[table_pdu_type_and_connectivity]]
[options="header"]
|===
|PDUタイプ           | 無向/有向  | スキャン要求  | 接続要求
|ADV_IND            | 無向       | できる      | できる
|ADV\_DIRECT\_IND   | 有向       | できない    | できる(特定デバイス)
|ADV\_NONCONN\_IND  | 無向       | できない    | できない
|ADV\_SCAN\_IND     | 無向       | できる      | できない
|===

PUDタイプごとの機能をまとめたものが <<table_pdu_type_and_connectivity>> です。

ADV\_INDとADV\_DIRECT\_INDは、接続を受け入れるタイプです。ADV\_INDが、いわゆる通常のアドバタイジングです。不特定多数のデバイスにそのデバイスの存在をつたえて、接続要求があればそれを受け入れます。ADV\_DIRECT_INDは、以前に接続したことのあるデバイスと高速に接続するためのタイプです。

ADV\_NONCONN_IND と ADV\_SCAN\_IND は、接続要求を受け入れないタイプです。位置ビーコンのように、アドバタイジング・パケットのみで情報をブロードキャストするものに使います。

===== パブリック・デバイス・アドレスとランダム・デバイス・アドレス

ADV\_INDタイプのペイロードは、6オクテットのアドバタイザのアドレスと、0から31オクテットのアドバタイジング・データとで構成されます ( [#fig_adv_ind_pdu_format] )。

![ #fig_adv_ind_pdu_format ADV\_IND PDUフォーマット](fig/ch02_adv_ind_pdu_format.png)

パケットのアクセス・アドレスは、通信ごとにランダムな値です。ADV_INDのペイロードにある、この48ビットのアドレス AdvA は、デバイスを特定するアドレスです。このアドレスには、
パブリック・デバイス・アドレス(Public device address)とランダム・デバイス・アドレス(Random device address)の2種類があります。AdvAがいずれかは、ヘッダのTxAddの値で示します。TxAddrが0ならばパブリック・デバイス・アドレス、1ならばランダム・デバイス・アドレスです。

パブリック・デバイス・アドレスは、Bluetooth SIGが企業ごとに発行した24ビットの識別子と、企業が製品1つづつに割り振る24ビットの識別子から構成されます。このアドレスは、製造時に書き込まれるデバイスに固有で唯一の値です。ランダム・デバイス・アドレスは、ハッシュ値とランダム値から構成されます。ランダム値は適当な一定時間ごとに変更されます。ハッシュ値は、デバイスが持っている128ビットのIRK(Identity Resolving Key)とランダム値から指定されたハッシュ関数で計算される値です。

ランダム・デバイス・アドレスはプライバシーを守るためにあります。パブリック・デバイス・アドレスは、デバイスそれぞれに割り振られた固有の値です。個人が持っているデバイスが、何かのきっかけでマスターとの接続が切断したとします。すると、デバイスは再接続をするためにアドバタイジングを始めます。このアドバタイジング・パケットは、誰でも傍受できます。ですから、アドバタイジング・パケットのアドレス AdvA から特定のデバイスの追跡が可能です。

ランダム・デバイス・アドレスを受信したスキャナは、事前にアドバタイザから受け取ったIRKを使い、ハッシュ値を計算します。このハッシュ値が、アドバタイジング・アドレスのハッシュ値と同じならば、それが目的のデバイスだとわかります。

===== アドバタイジング・データのフォーマット

Generic Access Profile(ジェネリック・アクセス・プロファイル、GAP)は、デバイスの発見と接続、そして通信データを暗号化するときは、鍵の交換をどのように行なうかを定義するものです。このGAPは、振る舞いを定義するものなので、リンク層から後に登場するGeneric Attribute Protocol(GATT)まで、層をまたいだ定義になります。次節のアドバタイジング・データのフォーマットは、GAPのシナリオから定義されています。

![ #fig_adv_data_format Adv Dataのフォーマット](fig/ch02_adv_data_format.png)

アドバタイジングの1つの情報をAD structureという単位で、それらの配列になっています。AD Structureは、1オクテットのLengthと、それに続く_Length_オクテットのDataです。Adv Datの長さは、1パケットのペイロードの制約で、31オクテットまでです。

AD structureのDataは、1オクテットのAD typeと_(Length-1)\_オクテットのAd Dataで構成されます。AD typeは、いくつもありますが、知っておくべきものは次の5つです:

- Flags
- Local Name
- Manufacturer Specific Data
- TX Power Level
- Service UUIDs

====== Flags

デバイスがもつ発見や接続の機能を示すのがFlagsです。AD typeの値は0x01です。ビット0/1は、それぞれ論理値false/trueに対応します。Flagsは、アドバタイジング・パケットに1つだけ含めます。

.Flagsのビット割り当て
[options="header"]
|===
|AD type |ビット |記述
|0x01    |0     |LE Limited Discoverable Mode
|        |1     |LE General Discoverable Mode
|        |2     |BR/EDR Not Supported
|        |3     |Simultaneous LE and BR/EDR to Same Device Capable (Controller)
|        |4     | Simultaneous LE and BR/EDR to Same Device Capable (Host)
|        |5..7  | Reserved
|===

 Bluetooth low energy のみをサポートするシングルモード・デバイスは、BR/EDR Not Supported は'1'、Simultaneous LE and BR/EDR to Same Device Capable は、ホストとコントローラいずれも'0'になります。

Limited Discoverable Modeは、デバイスを発見できる時間制限があることを示します。接続が切れたからといって、不用意にアドバタイジングをさせたくない場合に使います。General Discoverable Modeは、常にデバイスが発見できるモードを示します。通常はこのモードを使います。

====== Local Name

Local name(ローカル ネーム)は、ユーザ・インタフェースの表示名などに使われる、ユーザが読めるデバイスの名称を示します。これはアドバタイジング・データかスキャン・データのいずれかに1つだけ含めます。文字列はUTF-8で符号化されます。C言語の'\\0'のような、文字列の終端記号は必要ありません。

AD typeは、Shortened local name(ショーテンド ローカル ネーム)とComplete local name(コンプリート ローカル ネーム)の2つがあります。

.ローカルネームのAD type
[options="header"]
|===
|AD type | 記述
|0x08    |Shortened local name
|0x09    |Complete local name
|===

Complete local nameは、デバイスの完全な名前です。しかしAdv Dataは最大31オクテットですから、ローカルネームが29バイトよりも大きいと、収まりません。この場合には、Shortened local nameを使います。これは完全なデバイス名の先頭部分を取り出したものです。例えば、完全なローカルネームが‘BT\_Device\_Name’ならば、短縮したローカルネームは、例えば‘BT_Dev’となります。人間が読んで意味がわかる区切りで切り出すとよいです。

Shortened local nameが使われた時、完全なローカルネームは、上位層のGATTを通して、Device name characteristic から読み出せます。

====== Manufacturer Specific Data

Manufacturer Specific Data(マニュファクチャラ スペシフィック データ)は、それぞれの企業の任意データに使われます。AD type は 0xFFです。Ad Dataは、先頭2オクテットが
Bluetooth SIGが企業に発行した識別子、そして任意長のバイナリ・データが続きます。企業の識別子は [Company Identifiers documents](https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers) [^2060] にリストがあります。

[^2060]: [Company Identifiers documents https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers](https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers)

位置ビーコンのような、非接続で周囲の不特定多数の Bluetooth low energy デバイスに同報するときに、データの格納に使えます。

====== Tx Power Level

送信電力を表します。AD typeは0x0Aで、Ad Dataは符号付きバイトの値のみがあります。値の単位はdBmで、-127 から +127dBm までの値を示します。

Tx Power Levelは、アドバタイザとの距離の推定に使います。この値と受信したパケットの受信信号強度(Received Signal Strength Indication, RSSI)から、伝搬損失(pass loss)は次の式で求められます:

$$ 伝搬損失 = Tx Power Level – RSSI $$

デバイス間の距離が離れるほど伝搬損失が大きくなりまが、残念ながら、電波の直接波と反射波の干渉で生じるフェーディング、アンテナの放射パターンなど、様々な要素により、伝搬損失は単純な距離の関数とはなりません。デバイスが近いか遠いかを推定する、ことには使えます。

===== Service UUIDs

Bluetooth low energy のサービスは、機能を表します。例えば、エアコンであれば、温度設定といった制御値の入力機能、あるいは現在の室温といった計測機能が、それぞれ独立したサービスになります。機能の識別子にはUUID（Universally Unique Identifier)という128ビットの値が使われます。しかし128ビットそのままでは通信に時間がかかるので、Bluetooth SIGが承認したサービスには16ビットに短縮したUUIDが割り当てられています。

AD typeは、アドバタイザが持っているサービスのUUIDの配列を示します。31オクテットに収まる範囲で、主たる機能を表すサービスのリストを列挙します。

.AD type
[options="header"]
|===
|値    | 概要                   | 備考
|0x02  | 16-bit Service UUIDs  | More 16-bit UUIDs available
|0x03  | 16-bit Service UUIDs  | Complete list of 16-bit UUIDs available
|0x04  | 32-bit Service UUIDs  |  More 32-bit UUIDs available
|0x05  | 32-bit Service UUIDs  | Complete list of 32-bit UUIDs available
|0x06  | 128-bit Service UUIDs | More 128-bit UUIDs available
|0x07  | 128-bit Service UUIDs | Complete list of 128-bit UUIDs available
|===

==== 接続と通信

アドバタイザが送信したアドバタイジング・パケットに、イニシエータがコネクション・リクエスト・パケット(CONNECT\_REQ)を返信すると、接続状態になります。接続した2つのデバイスの役割は、イニシエータがマスターに、アドバタイザがスレイブに、それぞれ切り替わり、接続状態(図のCONNECTED)に遷移します。

アドバタイジングはアドバタイザがパケットの送出タイミングを制御していました。接続後はマスターがタイミングを制御します。接続後、マスターは一定期間ごとに、スレイブにパケットを送信します。スレイブはマスターからのパケットに返信する形で、データを送ります。マスターは複数のスレイブと接続します。マスターがスレイブに最初に送るパケットの送信タイミングで、スレイブそれぞれとの通信タイミングが重ならないようにします。

===== 通信のタイミング

![ #fig_ble_connection_timing 接続時のパケット通信](fig/ch02_ble_connection_timing.png)

接続確立と通信のタイミング図です。アドバタイジング・パケットの送信完了から150マイクロ秒後に、イニシエータはCONNECT\_REQを送信します。イニシエータはアドバタイザがCONNECT\_REQを受信できたかを、確認しません。もしもアドバタイザがCONNECT\_REQを受信しておらず、接続状態に遷移していない場合は、マスターがしばらく通信できないので、接続が切断したと判断します。

CONNECT\_REQパケットには、表の接続パラメータが入っています。パラメータの複合語は、先頭は小文字につづく単語は先頭を大文字にして連結(CamelCase、キャメルケース)します。

transmitWindowOffset(transmit window offset、トランスミット・ウィンドウ・オフセット)は、CONNECT_REQを送信してから、次のtransmit window sizeが始まるまでの、オフセット時間を示します。

transmitWindowSize (transmit window size、トランスミット・ウィンドウ・サイズ)は、最初のデータ・パケットを送信できる期間を示します。

connInterval(connection interval、コネクション・インターバル)は、チャンネルをホップする周期を示します。

connSlaveLatency(connection slave latency、コネクション・スレイブ・レイテンシ)は、スレイブが送信するデータがなにもないときに、コネクション・イベントを無視出来る回数を示します。

connSupervisionTimeout(connection supversion timeout、コネクション・スーパービジョン・タイムアウト)は、接続が失われたと判断する、コネクション・イベントの失敗回数を示します。

.接続パラメータ
|===
|名称                    | 値の制約     | 値の範囲
|transmitWindowOffset   | 1.25 ms 単位 | 0 ms 以上 connInterval 以下
|transmitWindowSize     | 1.25 ms 単位 | 1.25 ms 以上、10 ms、
|                       |             | もしくは(connInterval - 1.25 ms) 以下
|connInterval           | 1.25ms 単位  | 7.5 ms 以上 4.0 s 以下
|connSlaveLatency       | 整数         | 0以上最大値以下 *1
|connSupervisionTimeout | 10ms 単位    | 100ms 以上 32秒 以下 *2
|===

- \*1 最大値は ((connSupervisionTimeout / connInterval) - 1) かつ 500以下。
- \*2 (1 + connSlaveLatency) * connInterval よりも大きいこと。

マスターは、CONNECT\_REQを送信してから、(1.25ミリ秒 + transmitWindowOffset)あと、transmitWindowSize の期間中に、最初のデータ・パケットを送信します。マスターは、この最初のデータ・パケットから、一定期間ごとに、スレイブにデータ・パケットを送信します。マスターは複数のスレイブと接続するので、他のスレイブと通信タイミングが重ならないように、この最初のデータ・パケットの送信タイミングで調整します。その調整幅が transmitWindowSize になります。

最初のデータ・パケットの送信タイミングから一定期間 connInterval ごとに、コネクション・イベントが発生します。マスターとスレイブは、ともに送信すべきデータがあり、送信するパケットがコネクション・インターバルに収まるかぎり、データ・パケットをやりとりします。

このコネクション・イベントで、マスターとスレーブで通信タイミングを同期することで、高周波回路の消費電力を必要最小限にしています。スレーブは、マスターがパケットを送信するタイミングにあわせて、受信回路を動かして、消費電力の大部分を占める高周波回路の駆動時間を必要最小限にします。

コネクション・イベントごとに、通信につかう周波数帯域、チャンネルを切り替えます。チャンネルの切り替えは、チャネル番号ごとに順番に1つづつ移動するのではありません。マスターとスレーブが接続時に交換するパラメータ、次の節で述べるLLDataのChM と Hop の2つの変数で計算したチャネルに、ホッピングしていきます。もしもあるチャンネルで通信ができなくても、そのチャンネルで再接続や再送処理をすることはありません。次のコネクション・イベントで、別のチャンネルに切り替えて、通信を継続します。

スレーブに送るべきデータができたときから、そのデータがマスターに送信されるまでの時間を、遅延時間 レイテンシ、と呼びます。コネクション・インターバル connInterval が20ミリ秒であれば、スレーブは20ミリ秒ごとにデータを送信する機会があるので、レイテンシは、最大が20ミリ秒、平均すれば10ミリ秒になります。connIntervalを短くするほどレイテンシは小さくなりますが、それだけ無線通信の電力消費量も大きくなります。小さいレイテンシと超低消費電力を両立させるための工夫が、コネクション・スレーブ・レイテンシです。

コネクション・スレーブ・レイテンシ connSlaveLatency は、スレイブがコネクション・イベントを無視できる回数を表します。スレーブに送信すべきデータがないとき、スレーブは connSlaveLatency までコネクション・イベントを無視できます。スレーブは送信すべきデータがなくても、(connSlave Latency + 1)回目のコネクション・イベントには返信をします。もしも(connSlave Latency + 1)回目のコネクタ・イベントで、スレーブがマスターからの返信を受け取れなかった場合は、通信が成立していないものとみなして、通信できるまで、その後のコネクション・イベントに返信をします。

例えば connInterval が20ミリ秒、connSlaveLatencyが 5 とします。スレーブに送信すべきデータがないならば、5回のコネクション・イベントを無視できます。そして6回目のコネクション・イベントに返信をします。つまり、レイテンシは20ミリ秒のままで、スレーブの無線通信頻度を100ミリ秒、1/5 の電力に抑えられます。

コネクション・スーパービジョン・タイムアウト connSupervisionTimeout は、通信が切断したと判断する時間です。マスターおよびスレーブはそれぞれ、通信をしない時間が コネクション・スーパービジョン・タイムアウト を超えたならば、通信が切断したと判断します。スレーブは、コネクション・スレーブ・レイテンシ だけパケットを無視できます。

コネクション・スーパビジョン・タイムアウトが最小値 $ (connSlaveLatency + 1  ) * 1.25ミリ秒 $ のとき、connSlaveLatencyだけパケットを無視したスレーブと、その次のコネクション・イベントで通信ミスが生じれば、直ちに切断してしまいます。頻繁な切断を避けるには、connSupervisionTimeout を目安として connSlaveLatency の6倍程度に設定します。例えば connSlaveLatency が5、connIntervalが20ミリ秒のとき、conSupervisionTimeout は ( 5 * 20ミリ秒 ) * 6 = 600ミリ秒 に設定します。

===== CONNECT_REQ PDUペイロード

[#fig_connection_req_pdu_format]は、イニシエータがアドバタイザに送るCONNECT_REQのPDUのフォーマットです。InitAおよびAdvAは、それぞれイニシエータとアドバタイザのアクセス・アドレスです。アドバタイザはAdvAが自分宛であることを確認して、接続状態に遷移します。LLDataは22オクテットの接続パラメータです。


![ #fig_connection_req_pdu_format CONNECT\_REQ PDUフォーマット](fig/ch02_connection_req_pdu_format.png)

AA は、接続した後のデータ・パケットのアクセス・アドレスです。アドバタイジング・パケットのアクセス・アドレスは固定値でした。データ・パケットのアクセス・アドレスには、イニシエータがランダムに生成したアクセス・アドレスの制約条件を満たす値が使われます。

CRCInit はパケットのチェックサムを検査するシフトレジスタの初期値を指定します。CRCInitは、イニシエータがランダムに生成します。シフトレジスタは巡回検査符号を計算するためのハードウェアです。 Bluetooth low energy の巡回検査符号は、
多項式 $ x^24 +x^10 +x^9 +x^6 +x^4 +x^3 +x +1 $ を24個のシフトレジスタで実装した回路で計算されます。パケットの受信処理を開始する都度、これらのシフトレジスタは、CRCInitの値で初期化されます。ちなみに、アドバタイジングのときは、シフトレジスタは固定値 0x555555 で初期化されます。

WinSize、WinOffset、Interval、LatencyおよびTimeoutは、それぞれ前節のtransmitWindowSize、transmitWindowOffsetvalue、connInterval、connSlaveLatency、およびconnSupervisionTimeの値を表します。WinSizeなどの値は2オクテットの整数です。接続パラメータの物理値は、これらの整数値それぞれに値の制約の単位をかけたものです。例えば、$ transmitWindowSize = WinSize * 1.25ミリ秒 $ です。

ChMは、チャネルマッピングを表します。コネクション・イベントでどのデータ・チャネルを使うかを指定します。WiFiなどの、干渉するとわかっている周波数帯域のデータ・チャンネルを使わないようにして、干渉を回避するのに使います。ChMは4オクテットの値で、それぞれのビットがチャンネルに対応します。最下位ビットがチャンネル0、下位から36ビット目がチャンネル36に対応します。チャンネルを指定するときは、チャンネル10とチャンネル11の間には、アドバタイジング・チャンネル38があり、データ・チャンネルだけをみると周波数帯域が1つ飛ぶことに、注意します。

hopIncrementは、データ・チャンネルの切り替え順番を指定します。あるコネクション・イベントでチャンネル A を使った時、次のコネクション・イベントで使うチャンネル B は
$ B = (A + hopIncrement) mod 37 $ で求めます。この式の _mod_ は剰余の演算子です。例えば、hopIncrementが5のとき、あるコネクション・イベントでチャンネル3を使っていれば、次のコネクション・イベントは、$ ( 3 + 5 ) % 37 = 8 $ から、チャンネル8をつかいます。もしもチャンネル・マッピングで利用不可のチャンネルが指定されている場合は、そのチャンネルは使いません。利用可能なチャンネルがでるまで、

hopIncrementの値が小さすぎると、周波数があまり離れていないチャンネルに移動します。もしもWiFiなどの混信があると、チャンネル・ホッピングとしても影響を受けやすくなります。また16よりも大きくしていっても、剰余演算なので、逆にホッピング先が近くなります。ですから、値を大きくする意味がありません。37は素数なので、5から16までのどの値をとっても、37のチャンネルを、いつかは選択することになります。

SCAはマスターのスリープ・クロックの精度を表します。これは、マスターがコネクション・イベントで送信するパケットを、スレーブが取りこぼさないために必要です。マスターもスレーブも、高精度の発振回路を搭載していますが、それでもppm(百万分の1)の桁のずれが生じています。スレーブは、発振回路のずれから生じるコネクション・イベントのパケット送信タイミングのずれ時間分だけ、受信回路の動作開始時刻を前にずらします。


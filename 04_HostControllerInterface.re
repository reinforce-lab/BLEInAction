= HCI, L2CAP, SMP

== 通信

[#fig_data_channel_format]は、接続したマスターとスレーブのデータ・パケットのPDUののフォーマットです。2オクテットのヘッダと、0~33オクテットのペイロード、そして通信を暗号化していてペイロードが0より大きいときは、4オクテットのMessage Integrity Check(MIC)がつきます。

![ #fig_data_channel_format データチャネル PDUフォーマット](fig/ch02_data_channel_format.png)

データチャネルPDUの最大長さは、パケットフォーマット(<!--TBD   -->)のPDUの最大長さ39オクテットで制約されます。暗号化をしていないならば、MICの4オクテットをペイロードとして使えそうなものですが、暗号化の有無でバッファ長が変化しない設計になっています。

データ・チャネルPDUは、上位層 Logical Link Control and Adaptation Protocol (L2CAP)のパケットを分割送信します。

データ・チャネルPDUのヘッダは次の表のフォーマットです。

.データ・チャネルPDUのヘッダ
[options="header"]
[cols="2"]
|===
|フィールド名  | 記述
|LLID
| ロジカル・リンクID (Logical Link Identifier)
パケットの種類を示す。
00b = Reserved
01b = LL Data PDU (Continuation)
10b = LL Data PDU (Start)
11b = LL Control PDU
|NESN        | Next Expected Sequence Number
|SN          | シーケンス番号 (Sequence Number)
|MD          | モア・データ (More Data)
|Length      | ペイロードとMICのオクテット単位の長さ
|===

データチャンネルPDUは、LLIDの値で、ロジカル・リンク・データPDU(LL Data PDU)と、ロジカル・リンク・コントロールPDU(LL Control PDU)の2種類にわけられます。

=== ロジカル・リンク・データPDU

ロジカル・リンク・データPDUは、上位層( Bluetooth low energy ではL2CAP)のパケットの分割転送と受信時の再構築に使われます。

上位層(L2CAP)のパケット長がデータ・チャネルPDUのペイロードよりも長いとき、上位層からのパケットは複数のロジカル・リンク・データ PDUに分割して送信されます。一連のパケットの列は、最初のパケットのLLIDが 10b(Start、始めの) 、それに続くパケットの LLIDを 01b (Continuation、続きの)にして判別します。

![ #fig_logical_link_data_pdu_format ロジカル・リンク・データ PDUフォーマット](fig/ch02_logical_link_data_pdu_format.png)

上位層のパケット長がデータ・チャネルPDUのペイロードにおさまるときは、LLID 01bのパケット1つだけで、その後にLLID 01bのロジカル・リンク・データPDUは続きません。

ロジカル・リンク・データPDUに、上位層のパケット長を示すフィールドはありません。リンク層は、上位層からデータが来れば、順次それをStartとそれに続くContinuationのデータ・パケットに分割するだけです。ですから、リンク層は上位層のパケット長を事前に知る必要はありません。

Lengthはペイロードのオクテット長を示します。LLID 10b (Start)のデータPDUのLengthは0より大きい値、LLID 01b (Continuation)のLengthは0を含む値がとれます。LLIDが 01b (Continuation)でLengthが0のパケットを、エンプティ・パケット(Empty packet)と呼びます。

エンプティ・パケットは、フロー制御に使います。Continuationのパケットで<!--TBD  パケット分割の図 -->
送信すべきデータ揃っていないときは、エンプティ・パケットを埋め草として使います。またコネクション・イベントで、マスターからスレーブにパケットを送信するとき、マスターから送信すべきデータがないとき、また逆にスレーブがマスターにデータはないが接続を確認するために返信するときにも、エンプティ・パケットを使います。

<!-- 4.5.9 Acknowledgement and Flow Control vol.6 -->
Sequence number(シーケンス番号、SN)とNext expected sequence number(ネクスト・イクスペクテッド・シーケンス番号、NESN)は、信頼できるパケット通信とフロー制御に使われます。

SNとNESNは1ビットの値です。マスターとスレーブはコネクション状態に入るときに、SNとNESNをそれぞれ0に初期化します。SNは自分が送信するパケットのシーケンス番号を、NESNは相手に次に送ってほしいパケットのシーケンス番号を設定します。

マスターがコネクションイベントで、(SN = 0, NESN = 0)のデータ・チャネルPDUをスレーブに送ったとします。スレーブがこのパケットを受信して、次のパケットの送信を求めるならば、スレーブは NESN = 1 のデータ・チャネルPDUを送信します。マスターは、スレーブが NESN = 1 を送ってきたのをみて、直前に送信したSN＝0のパケットをスレーブに送信できたと確認できます。マスターは次はSN = 1のパケットを送信します。

マスターが(SN = 0, NESN = 0)のデータ・チャネルPDUをスレーブに送った時、スレーブがパケットのビットエラーを検出したとします。スレーブは、マスターに SN = 0 のパケットを再送してもらうために、NESN = 0 のデータ・チャネルPDUを送信します。マスターは、スレーブがNESN = 0 を送ってきたのをみて、SN = 0 のパケットを再送します。

この仕組は、フロー制御にも使えます。例えば、スレーブの受信バッファがいっぱいで、パケットのペイロードを読み込めないときは、マスターにそのパケットの再送を要求します。

送信側から見て、送信先がパケットの受信に失敗する原因は、電波状態が悪いなどで、パケットにビットエラーが発生またはパケット自体を検出できていない場合と、先のフロー制御のように送信先の処理速度が追いつかない場合の2つがあります。送信側から見て送信先から返ってくる反応は、何も返ってこない、再送を要求するパケット(直前に送ったパケットのSNが NESN に設定されている)が返ってくる、および正常に受信できた(直前に送ったパケットのSNと違う値が NESN に設定されている)の3通りです。何も返ってこない場合は、次のコネクション・イベントで通信を再同期します。なにかしらパケットが返ってきた場合は、送信側は、再送もしくは次のパケットを送信します。

SNおよびNESNは1ビットの値です。マスターとスレーブはピコネット内で交互にパケットをやりとりします。ですから、パケット伝送の遅延時間が大きい場合にスループットを上げる目的で使われる、パケットの先送りがありません。ですから、SNおよびNESNは1ビットでよいのです。

MD(モア・データ、More Data)は、接続先デバイスに送信すべきデータがまだあることを示す1ビットの値です。MDが1ならデータが未だある、0ならば送信すべきデータはもうない、ことを示します。MDが1である限り、パケットのやり取りが継続します。もしもコネクション・インターバルの終わりになっても、MDが1ならば、そのコネクション・イベントは自動的に延長されて通信が継続します。逆にMDが0であれば、それ以上のデータはないとわかるので、直ちにスリープ状態に入るなどして省電力化ができます。

=== ロジカル・リンク・コントロールPDU

ロジカル・リンク・コントロールPDUは、リンク層の接続制御に用います。ロジカル・リンク・コントロールPDUのフォーマットは、1オクテットのopcode(オペコード)と0から22オクテットのCtrData(コントロール・データ、control data)で構成されます。次の表は、オペコードの値とその意味です。

.オペコードの値とその意味
[options="header"]
|===
|オペコード  | コントロールPDU 名
|0x00      | LL\_CONNECTION\_UPDATE_REQ
|0x01      | LL\_CHANNEL\_MAP_REQ
|0x02      | LL\_TERMINATE_IND
|0x03      | LL\_ENC_REQ
|0x04      | LL\_ENC_RSP
|0x05      | LL\_START\_ENC_REQ
|0x06      | LL\_START\_ENC_RSP
|0x07      | LL\_UNKNOWN_RSP
|0x08      | LL\_FEATURE_REQ
|0x09      | LL\_FEATURE_RSP
|0x0A      | LL\_PAUSE\_ENC_REQ
|0x0B      | LL\_PAUSE\_ENC_RSP
|0x0C      | LL\_VERSION_IND
|0x0D      | LL\_REJECT_IND
|0x0E-0xFF | 将来のために予約
|===

LL\_CONNECTION\_UPDATE\_REQ と LL\_CHANNEL\_MAP\_REQ は、コネクションのパラメータおよびチャンネル・マッピングを更新するオペコードです。やり取りするパラメータは、コネクション時のLL Data と同じものです。これらのオペコードは、マスターのみが使えます。それは、これらの接続パラメータの値を決められるのは、ピコネットの通信を制御しているマスターのみだからです。もしもスレーブが接続パラメータを更新したいときは、リンク層の上位層のL2CAPの、LE signaling channnel を使います。

LL\_CONNECTION\_UPDATE\_REQ のCtrlDataのフォーマットの WinSize、WinOffset、Interval、Latency、および Timeout は、それぞれ transmitWindowSize、transmitWindowOffset、connInterval、connSlaveLatency、および connSupervisionTimeout と同じ意味を持ちます。

Instant は、どのコネクション・イベントで、接続パラメータを更新するかを指定します。マスターとスレーブはそれぞれ、コネクション状態になってからのコネクション・イベントの数を connEventCount というカウンタで計測しています。Instantが示すコネクション・イベントのタイミングで、接続開始時の処理を行い、アンカー・ポイントの再設定を行います。 LL\_CHANNEL\_MAP\_REQ も、これと同様です。

オペコード 0x03 (LL\_ENC\_REQ) から0x0B (LL\_PAUSE\_ENC\_RSP) は、パケットの暗号化のコマンド群です。LL\_ENC\_REQとLL\_ENC\_RSPは、暗号/復号処理に必要な情報をやり取りします。LL\_START\_ENC\_REQ と LL\_START\_ENC\_RSP は暗号化の開始を、LL\_PAUSE\_ENC\_REQ と LL\_PAUSE\_ENC\_RSP は暗号化の中断のコマンドです。

データ・チャネルPDUのヘッダのLengthフィールドは、ペイロードとMICを合わせた長さを示します。またパケットが暗号化されている/いないを示すフラグはありません。ですが、マスターとスレーブは、ロジカル・リンク・コントロールPDUで、今の通信が暗号化されている/いないがお互いにわかるので、暗号化を示すフラグは必要ありません。

LL\_FEATURE\_REQ および LL\_FEATURE\_RSP は、マスターおよびスレーブのリンク層の機能を示すデータをやりとりします。いまの規格は、暗号化サポートの1ビットのみを定めています。 Bluetooth low energy のリンク層の機能は、デフォルトですべての機能が有効になっています。接続時に、機能サポートを調べる必要はありません。もしも機能がサポートされていなければ、そのコマンドはリジェクトされます。そのエラー原因は、リジェクトで返される LL\_REJECT\_IND の、CtrDataにあるエラーコードから取得できます。

LL\_VERSION_IND はコントローラのバージョン番号を示します。おもな用途は、接続時にトラブルが生じた時などの、デバックです。Bluetooth Controller の仕様番号、製造者番号、および実装番号が取得出来ます。仕様番号および製造者番号はBluetooth SIGが割り当てた値が使われます。

LL\_UNKNOWN\_RSP PDUは、LLコントロールPDUが予約されたオペコードや不正なCtrlDataを含むとき、そのレスポンスに使われます。

LL\_REJECT\_IND は、コマンドをリジェクトした時のエラーコードを返します。例えば、暗号化処理を要求したときに、相手先が暗号化処理を行えないときは、 ENCRYPTION MODE NOT ACCEPTABLE (0x25) が返されます。また、暗号化を必要とするGATTのキャラクタリスティクスへの読み書き等を、暗号化を開始せずに実行したときは、 INSUFFICIENT SECURITY (0x2F) が返されます。

== Logic Link Control and Adptation Protocol

リンク層は接続デバイスとの通信路を提供します。Bluetoothには、この1本の通信路で様々なプロトコルやアプリケーションの通信を提供するために、Logic Link Control and Adptation Protocol (L2CAP、エルトゥーキャップ、頭文字のLが2続くのをL2と略している)があります。

L2CAPは、チャンネルという考え方で通信を多重化します。上位層のパケットの分割と統合、チャンネルごとのフロー制御とパケット再送制御、エラー・コントロールを提供します。Bluetoothでは、例えばヘッドセットなど一定のビットレートでストリーミングをするものや、ファイル転送など、大容量の情報を可能な限り高速で送信するものなど、アプリケーションごとに必要とするネットワークの特性が異なります。L2CAPは、必要とする特性にあわせた通信路を提供します。上位層のプロトコルおよびアプリケーションからみると、他のプロトコル/アプリケーションの通信状態にかかわらず、相手側のプロトコルおよびアプリケーションとの通信が確保されていると見えます。

クラシックBluetoothのL2CAPは、チャンネルを確立するときに、フロー制御などのパラメータをやりとりするために、複雑でまた処理時間もかかります。クラシックBluetoothは、一度接続すれば長時間接続しつづける用途に使われるので、接続時にかかる時間は許容されます。

しかし Bluetooth low energy は、コネクションを維持するものではありません。簡単に接続して、簡単に切断してしまうものです。これにL2CAPを対応させるために、 Bluetooth low energy のL2CAPは、固定されたチャンネルのみが提供されます。この固定チャンネルでは、接続時のパラメータのやりとりはありません。

<!-- [Vol 3] page 38 of 656 2.1 CHANNEL IDENTIFIERS-->
Bluetooth low energy のL2CAPのチャンネルは、3つの固定チャンネルだけです。

.L2CAPのチャンネル
[options="header"]
|===
|Channel ID    | 説明
|0x0004        | Attribute Protocol
|0x0005        | Low Energy L2CAP Signaling channel
|0x0006        | Security Manager Protocol
|===

=== パケット構造

L2CAPのパケット構造は、2バイトのLengthとChannel ID、それに0から65535バイトまでのinformation payloadが続きます。

![ #fig_l2cap_packet_format L2CAP パケット・フォーマット](fig/ch02_l2cap_packet_format.png)

チャンネルID 0x0005 のシグナリング・チャンネルのフォーマットは、1バイトのコードと識別子、2バイトの長さと任意長のデータが続きます。コードは次の3つだけです:

- Connection Parameters Update Request/ Response
- Command reject

シグナリング・チャンネルのIdentifierは、コマンドを発行した側が、0x00以外の値を設定します。コマンドを処理した側は、レスポンスにその識別子を設定して結果を返します。コマンド発行側は、複数のリクエストを同時に発行したときでも、この識別子の値から、どのコマンドに対する結果なのかがわかります。 Bluetooth low energy は、リクエストが1つですから、この処理はとても単純になります。

Connection Parameters Update Request/Responseは、スレーブからホストへの接続パラメータの変更要求に使われます。このConnection Parameters Update Requestは、スレーブはいつでもマスターに送信できます。マスターは送信できません。もしもサポートされていないコマンドを受信したり、データ長が期待した長さ(23バイト)ではない場合は、Command rejectが返されます。

このリクエストを受信したマスターは、その変更パラメータを受け付けるならば、レスポンスで受け付けること(accepted) を返してから、ロジカル・コントロールPDUから接続パラメータを更新します。変更パラメータを受け付けないならば、レスポンスで受付拒否(rejected)を返します。マスターには、その他のスレーブとの接続や、WiFiやクラシックBluetoothとの共存などの制約があります。スレーブは、変更パラメータの値の範囲をなるべく広くとって、マスターが受け入れられるパラメータを選べるようにすべきです。

スレーブからのコネクション・パラメータのアップデート要求は、通信速度と省電力の両立に利用できます。マスターは接続時にスレーブから、ATT/GATTのサービスおよびキャラクタリスティクスを読み出します。ですから接続直後に通信速度が高いパラメータを選択すれば、素早い接続処理ができます。接続が完了した後は、アプリケーションに応じた通信頻度で、より低消費電力のパラメータに切り替えることで、省電力化ができます。これらの、パラメータの設定や切り替えは、スレーブの設計次第です。コネクション・インターバルが小さい値でも、スレーブ・レイテンシが高くできるならば、パラメータの変更は必要ないかもしれません。

== Bluetooth low energy で使われる暗号化方式

周囲に広がっていく電波を通信に使う無線通信技術は、第3者が通信を傍受してそこから重要な情報を盗み出したり、あるいは外部から電波を送信して権限がないのに装置を操作したりされる可能性があります。そのため、無線通信技術には高度な暗号化技術が不可欠になります。

暗号化とは、もともとのデータ(平文)を、特別な知識がない第3者がそれを見ても平文に解読できないデータに変換する方式のことです。暗号化は、データそれ自体の暗号化だけではなく、あるデータが確かに信頼できる発信元からのものだと確認するための署名の仕組みとしても利用されます。

暗号化方式は、通信などで流れ続けるデータ列を暗号化するストリーム暗号と、あるまとまったデータのかたまりを暗号化するブロック暗号に分類できます。暗号化およびその復号に使う特別な情報を鍵と呼びます。暗号化と復号に同じ鍵を使う方式を共通鍵方式、公開鍵と秘密鍵という2つの鍵を使う方法を公開鍵方式と呼びます。

暗号は、原理的には鍵を知らない第3者でも復号できます。暗号化データは電波を傍受して収集できますし、また暗号化方式は規格として公開されています。しかし、暗号化データから鍵を探し当てる計算量があまりに膨大で、現実的には解読できないことが、暗号を成り立たせています。

Bluetooth low energy で使われる暗号化方式は、AES-128と呼ばれる公開鍵方式のブロック暗号と、HOGEという公開鍵方式のブロック暗号です。ここでは、この2つの暗号化方式の概略を述べます。

=== AES(Advanced Encryption Standard)

1977年にアメリカ国立標準技術研究所は、DES (Data Encryption Standard) と呼ばれる共通鍵方式のブロック暗号を、FIPS 46 (Federal Information Processing Standards, 連邦情報処理標準) として公開しました。

DESはネットワーク技術を支える暗号化方式として広く使われてきました。しかし計算機の性能が桁違いに向上したことで、DESの鍵長56ビットでは短すぎるとして、より強力な暗号化方式が求められるようになりました。

AES(Advanced Encryption Standard)は、DESに代わる次世代暗号化方式として、2001年にアメリカ国立標準技術研究所が [FIPS 197](@<href>{http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf) [^ap-b-01])} として公開したものです。

[^ap-b-01]: [@<href>{http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf](http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf)}

暗号化方式には、その暗号は十分に強力なのだろうか、また一般に発表されていない秘密の方法があり、それを発見している人はこっそり暗号を解読しているのではないだろうかという疑いもあります。

そのような疑いがないように、AESは公募で提案を集めました。そして、設計内容に恣意的な説明がつかない処理部分がないかなどが、評価されました。その評価に耐えた方式が、AESとして採用されました。

AES(Advanced Encryption Standard)は、128ビット単位でデータを暗号化するブロック暗号で、暗号化と復号に同じ鍵を使う共通鍵方式です。鍵長は、128ビット、196ビットおよび256ビットのいずれかです。Bluetooth low energy が使う鍵長は128ビットです。

==== ブロック暗号

ブロック暗号は、固定長のデータの単位(これをブロックと呼びます)で暗号化をおこなう暗号の総称です。

平文を入力して暗号文にすることを暗号化、その暗号文を入力して平文に戻すことを復号と呼びます。暗号文が復号できるためには、1つよりも多くの平文が同じ暗号文を生成することはあってはなりません。

ブロック暗号は、秘密の変換表を使う固定長データの変換処理といえます。1文字をブロックにすれば、最も単純なブロック暗号になります。

暗号化する人と復号する人は、あるアルファベットとアルファベットを対応づける秘密の変換表を共有します。暗号化する人は、文章のアルファベットを1文字づつ、この表を見て暗号化します。復号する人は、逆に暗号化されたアルファベットを1つづつ平文のアルファベットに復号して、元の文章に戻します。

あたりまえですが、この暗号は簡単に破られます。平文には、単語や文章構成といった構造があるので、1文字をブロックにした暗号文では、平文の統計がそのまま含まれます。ですから、秘密の変換表を奪わなくとも、通信を傍受して十分な量の暗号文を手に入れるだけで、変換表が解読されます。

ですから、ブロックの固定長は、たとえ十分な量の暗号文を蓄積されても変換表が解読されない程度に設定されます。

ただし、ブロックが長くなると、変換表のサイズも大きくなります。例えば、ブロックの固定長が16バイト(128ビット)だとします。$ 2^128 $ 通りのブロックそれぞれが、どのブロックに対応するかを1対1で書きだすと、 $ 2^128 * 16 ~= 5*10^39 $ バイトになります。

2015年の時点で人類が蓄積したデータ量がエクサ( $ 10^18 $ )のオーダだそうです。ある1つの変換表のサイズだけでも、それよりも20桁以上大きい膨大なサイズです。また、変換表の数は、平文と暗号文の組み合わせの数だけありますから、2^128 の階乗程度とさらに膨大な数があります。

実際の暗号化では、変換表それ自体を書き出すことはありません。平文は、鍵と呼ぶ値で暗号化されます。ブロック暗号は、鍵の値が指定する変換表を使い、平文を暗号文に変換しているともいえます。あるいは、鍵の値をつかい、ブロックのデータをビット単位で撹乱しているとも言えます。

==== 暗号の解読方法

無線通信を傍受して、ある平文と暗号文の組を入手できたとします。もしも、これを手がかりにして鍵を見つけられるなら、それは暗号として使えません。

最も単純な解読方法は、総当り方式です。手に入れた平文を、手当たり次第に鍵を生成して暗号化して、もしも手に入れた暗号文と同じ暗号文が生成されれば、それが鍵だとわかります。

例えば、総当り方式で鍵を見つけようとすれば、どの程度の計算時間がかかるかを見てみます。例えば、全世界の人が一人一台高性能なパソコンを持っていて、それをすべて使って鍵を探すとします。

人類の人口を100億人、パソコンがとても高性能で1秒間に100億個 $ ( 10 G = 10^10) $ の鍵を探せるとします。そうすると、1秒間に $ 10^20 $、2のべき乗にすると約 $ 2^66 $ 個の鍵が探せます。
1年間は $ 3.2 * 10^7 秒 ~= ~ 2^25 秒 $ ですから、1年間で $ 2^91 $個の鍵が探せます。

鍵長が91ビット程度であれば、総当り方式でも1年以内に解読できそうです。しかし、AES-128の鍵長は128ビットですから、鍵は $ 2^128 $ 個あります。1年に解読できる鍵の数が、2の91乗、鍵の数が128乗ですから、解読には 2の37乗 $ ( ~= 1 * 10^11 ) $ 年と、現実的ではない時間がかかります。

総当り方式では現実的な計算時間で解読ができないのが、暗号が暗号になる根拠になります。ですが、もしも探索する鍵の範囲を絞り込める何かの方法があるならば、それは現実的な時間で解読可能になるかもしれません。

ブロック暗号の解読方法に差分解読方法というものがあります。これは例えば、1ビットだけ値が異なるブロックをいくつか入力して得られた暗号文から、鍵を推定する方法です。ブロック暗号は、この差分解読方法が使えない程度に、規則性や構造がないように、平文をランダムに暗号文に変換しなくてはなりません。

==== AES-128の暗号化処理

AES-128の暗号化処理の演算はバイト単位です。まず平文を、バイト・データを要素とする4x4の行列で表します。この行列に:

1. サブバイト変換
2. 行方向のバイト・データのシフト
3. 列単位の行列演算
4. 鍵の値を加算

この一連の4つの処理を10回繰り返した結果が暗号文になります。

サブバイト変換は、バイト・データをその逆元に変換します。逆元は、その値にかけると単位元になる値のことです。例えば、実数では単位元は1ですから、2の逆元は 1 / 2 = 0.5 です。この処理は、例えば8ビット目のビットがそれ以外の位置のビットと、ビット位置を超えて撹乱される処理になります。

行方向のシフトは、バイト位置の撹乱になります。列方向の演算は、同じビット位置の値の撹乱になります。

最後の鍵の値の加算は、ビット位置それぞれの値をランダムに変化させる撹乱になります。

復号処理は、暗号化処理とちょうど反対の処理になります。まず鍵の値を減算して、列方向に暗号化時に使った行列の逆行列をかけて、反対向きにシフトをして、サブバイト変換をすることを、10回繰り返します。

=== 暗号の複雑さ

平文を暗号文に変換する暗号化、そして暗号文を平文に戻す復号化は、特定の相手にのみメッセージを伝える技術として古くからあります。

例えば、棒に巻きつけたテープに横向きに文章を買いて、そのテープを解くと、そのテープを見ても意味ある文章は読み取れなくなります。この暗号は、棒に巻きつければ読み取れるという復号方法を知っていれば、意味ある文章が読み取れるまで、様々な太さの棒に巻きつけてみるだけで、解読できそうです。

また、イギリスの小説家、アーサー・コナン・ドイルのシャーロック・ホームズの短篇集「踊る人形」には、アルファベットを踊る人形の絵文字に置換した暗号が登場します。主人公シャーロック・ホームズは、絵文字がアルファベットに1対1に対応すると仮定して、一般的な英文に登場するアルファベットの頻度頻度といった平文にある統計的な性質を手がかりに、暗号を解読します。

この暗号を解読するのは、棒に巻きつけた文章よりも難しそうですが、ギガヘルツで演算するパソコンがあちこちにある現代では、アルファベットと絵文字のあらゆる組み合わせのなかから意味ある文章になる組み合わせを見つけ出す、
力技でも十分に解読できそうです。

何かの配列がの要素を入れ替える操作を図にすると、あみだくじのようになります。(TDB 図への参照) ここで、あみだくじで入れ替えられる値ではなく、あみだくじの操作自体に着目します。そうすると、あみだくじが入れ替える値が、文字列のアルファベット列、バイナリ・データのバイト列あるいはビット列などなんであっても、操作自体の複雑さは同じだと考えられます。

入力の要素が $$ n $$ 個のあみだくじを考えてみます。n 個を並び替える組み合わせの数は、$$ n! $$ 通りあります。

例えば、３つの記号 {a,b,c} の並べ替えは、(abc),(acb),(bac),(bca),(cab),(cba) の6通りあります。3個の要素の並び替えの数の計算は: まず3つの要素からどれか1つを取り出す取り出し方が3通りあります。次に、残る2つのいずれかの取り出し方が2通りあります。最後に残ったのは1つだけですから、取り出し方は1通りだけです。これを掛け算すると、$$ 3! = 3 * 2 * 1 = 6 $$ 通りと求まります。

横棒を増やしていけば、無数にあみだくじが作れます。しかし並び替えのパターンは $$ n! $$ 通りしかないので、横棒の数の見た目が違うだけで同じ演算処理を表すあみだくじがたくさんできるだけです。

あみだくじの図形を見ているだけではなにもわかりません。あみだくじの操作それぞれを元とする集合を考えます。元とは、集合を構成している個々のものを指します。要素とも言います。集合の元の間に一意な演算が成り立ち、その演算に関して集合が閉じているものを群と呼びます。

3つの記号を入れ替える3本のあみだくじの操作の元は、入力記号が(a,b,c)の時の並べ替え結果 (abc),(acb),(bac),(bca),(cab),(cba) の6つです。とくに、あみだくじのように、ものを並び替える操作を元とする群を、対称群と呼びます。

演算記号を仮に $$ \circule $$ として、次の3つを、群の公理と呼びます。

- 結合法則が成り立つ $$ \alpha \circle ( \beta \circle \ganma ) = (\alpha \circle \beta )\circle \ganma $$
- 単位元があること  $$ e \circule \alpha = \alpha $$
- 逆元があること    $$ \alpha \circle \alpha^{-1} = e $$

公理とは、これはこういうものだと最初に導入する最も基本的な仮定のことです。例えば、ユークリッド幾何学は、平行線は交わらない、を公理にしていますが、平行線はなぜ交わらないのか? とは考えません。しかし、平行線は交わるという公理からも幾何学は組み立てられ、それらは非ユークリッド幾何学と呼ばれます。

演算関係というと、たし算(加法)やかけ算(乗法)といった四則演算を思い浮かべますが、群はそれよりも範囲が広い概念です。四則演算に考えが縛られないように、演算器号を仮に $$ \circule $$  としました。

3本のあみだくじでみてみます。3つの要素a, b, c を並び替えた結果で操作を表すことにします。 $$ (acb)  \circle (bac) = (cab) $$ と、どの2つの元の演算も6つの操作いずれかになるので、この集合は演算に関して閉じています。

$$ \circule $$

(abc) ,

このあみだくじを暗号に使うとどうなるでしょうか。
$$ n! $$ 通りの入れ替えのどれを使うかの情報を鍵として、
複雑さがどの程度
の入れ替えを鍵にして
あみだくじの図形を見ているだけでは、


計算式、
f(x) = ax + b, g(x) = cx + d
g(f(x)9 = c(ax + b ) + d = (c * a) x + (c * b + d)
g(f(x)) = a * x + b

アーベル群
可換群、群は交換法則が成り立つとは限らない

==== ガロア体の四則演算

$$ \alpha, \beta \in G \Rightarrow \alpha \circule \beta \in G $$
$$ \alpha \circle ( \beta \circle \ganma) =  (\alpha \circle \beta )\circle \ganma $$
$$ \exists e s.t. \alpha \circle e = e \circle \alpha = \alpha for \forall \alpha \in G $$
$$ \exists a^{-1} s.t. \alpha \circle \alpha ^{-1} = e for \forall \alpha \in G $$



体、加減乗除ができる数の集合。

群の(定義)(公理)
以下の公理を満たす集合を群と呼ぶ
G1 演算 * に関して閉じている
G2 任意の元に対して、結合法則が成り立つ
G3 単位元が存在する
G4 任意の元に対して、その言に対する逆元が存在する

集合の元は、集合の要素、とも。同じこと。
x <= S3, y x <= S3, x * y <= S3、このことを閉じているという。

定義していれば、* はなんでもかまわない。
意味があれば。

結合法則

(x*y)*z = x*(y*z)

単位元
a*e=e*a=a

巡回群、1つの元で生成される群。
アルファをたして、群を拡張して、拡大体。
アルファの巡回群。
積。
積の繰り返しをべきじょう
生成元


方程式 x^12 -1 = 0 の解を求める
多項式x^12-1=0の根を求める。

次元、添加体、元を加える。元のとは独立。
どれだけ体が広がるか。

方程式をとくのは、要は因数分解。
因数分解では体を明確に。
方程式の解を全部く組んだ拡大体なら、方程式は1次の四季の積にいんす数分解できる。
方程式論=体の理論。

線形空間
q+pほえげら = 0 <=> p<=R, q<=R, p = q = 0











AESは、入力ブロックと鍵との四則演算を繰り返して、それぞれのビットを撹乱する暗号方式です。暗号化につかった鍵と同じ鍵を使い、暗号化の演算を逆順でおこなえば、復号できる共通鍵方式です。

AESはバイト単位で演算処理をします。もしも実数の四則演算を使うと、計算結果は実数になり1バイトで表現できる整数ではなくなってしまいます。例えば2を逆元にすると結果は0.5になりますが、これは1バイトで表現できません。ですから、出力ブロックの要素はバイトではなく浮動小数点型になってしまいます。

AESには、計算結果が常にバイトになる、バイトで四則演算が閉じた演算が必要です。1バイトが表すことが出来る数は、10進数で0から255までの256通りです。ですから、この256個の要素で四則演算が閉じた演算が必要です。

数学で四則演算ができる集合のことを体(field)と呼びます。小学校で最初に習う $ 1 + 1 = 2 $ は有理数の全体での演算です。体の要素の四則演算は、交換法則 a * b = b * a、結合法則 $ a*(b*c) = (a*b) * c $、分配法則 $ a *  (b + c) = a*b + a*c $ が成り立たなければなりません。

有理数の要素は無数にあるので、AESには使えません。ですが、有限個の要素で四則演算が閉じた集合も作れます。これを、有限体 (finite field)また発見者であるエヴァリスト・ガロアにちなんでガロア体(Galois field)と呼びます。

元が $ p^m $ 乗個のガロア体を $ GF(p^m) $ と表記します。pは素数、mは1以上の整数です。またガウス体の元の数(p^m)を位数と呼びます。

ガロア体の四則演算は剰余系です。例えば、最も要素の少ないGF(2)であれば、普通に整数の四則演算をして、それを2で割った余りになります。ある値Nをpで割った余りを、N modulo p と表記します。

GF(2)の元を0と1とすれば加減算は次のようになります。加算は単純な足し算です。(0-1)の減算は、GF(2)では 2 modulo 2 = 0 ですから、 ( 0 - 1 ) modulo 2 = ( 0 - 1 + 2 ) modulo 2 = 1 となります。GF(2)は加算と減算は同じ演算になります。

+ |0 1
--+-----
0 |0 1
1 |1 0

- |0 1
--+-----
0 |0 1
1 |1 0

* |0 1
--+-----
0 |0 0
1 |0 1

この方法でGF(256)ができればよいのですが、$ GF(p^m) $ はpが素数でなければ演算が閉じないので、素数ではない256ではガロア体が作れません。

GF(256)は大きな表になるので、例えば、GF(4)で演算結果をまとめると、このようになります。乗算の2の列をみると、単位元1がありません。つまりGF(4)は、2に逆元がないので演算が閉じません。

+ |0 1 2 3
--+--------
0 |0 1 2 3
1 |1 2 3 0
2 |2 3 0 1
3 |3 0 1 2

x |0 1 2 3
--+--------
0 |0 0 0 0
1 |0 1 2 3
2 |0 2 0 2
3 |0 3 2 1

また256よりも大きな素数pで、その元の256個の部分集合をどう選択しても演算は閉じません。AESは、GF(2)を係数にもつ多項式の剰余系 $ GF(2^8) $ を使います。

ところで、あるm次の多項式が割り切る $ x^n -1 $ の最小のnが $ (p^m -1) $ である多項式を、原始多項式(Primitive polynomial)と呼びます。

m次多項式の係数の取り方はいろいろありますが、かならず1つ以上の原始多項式があります。多項式を総当りで計算していけば、見つかります。

いまm次の原始多項式をF(x)

F(x) = 1 + c_1 x + c_2 x^2 + ... c_m x^m, c_m = 1

とします。係数 $ c_n $ はCF(2)の値なので、1または0のいずれかの値です。F(x)は原始多項式なので、

(x^(p^m -1) +1) modulo F(x) = 0

となります。このとき、$ F(x) = 0 $ の解の1つを $ \alpha $ とすると、そのべき乗 $ { 0, 1, \alpha^2, \alpha^3 ... \alpha^{p^m-2} } $ はすべて異なる値になります。

もしも、2つの値 $ \alpha ^ q, \alpha ^ q, (p^m - 2) > q > r >= 0 $ が等しいとしてみます。すると、

\alpha ^ q -\alpha ^ r =  0
\alpha ^ r (\alpha ^ (q - r) + 1)  = 0
つまり
\alpha ^ (q - r) + 1 = 0,  (p^m - 2) >= (q - r) > 0

が成り立たなければなりません。ですが原始多項式F(x)が割り切る最小のxのべき乗は $ p^m - 1 $ ですから、これは成り立ちません。つまり、$ \alpha $ のべき乗はすべて異なる値となります。

F(x)の剰余系で、$ { 0, 1, \alpha^2, \alpha^3 ... \alpha^{p^m-2} } $ はガウス体 $ GF(2^m) $ で演算が閉じます。

$ GF(2^8) $ では計算が大変なので、$ GF(2^4) $ を例に取ります。4次の原始多項式 $ F(x) = x^4 + x + 1 $ で、その解の1つを $ \alpha $ として、$ GF(2^4) $ の元 $ { 0, 1, \alpha^2, \alpha^3 ... \alpha^14 } $ を求めてみます。






$ GF(2^4) $ の元は $ { 0, 1, \alpha^2, \alpha^3 ... \alpha^14 } $ です。

GF(2)上では、F(x) modulo F(x) = 0ですから、x^4 + x + 1 = 0 です。$ \alpha $  はF(x)の解ですから、 $ \alpha^4 + \alpha + 1 = 0  $ でもあります。両辺から $ \alpha + 1 $ を引き算すると、GF(2)では足し算と引き算は同じですから、$ \alpha^4 = \alpha + 1 $  となります。

アルファの累乗の一部を計算すると、

\alpha^3  = \alpha^3
\alpha^4  = \alpha + 1
\alpha^7  = \alpha^4 * \alpha^3 = \alpha^3 + \alpha + 1
\alpha^14 = (\alpha^7)^2 = (\alpha^3 + \alpha + 1)^2 = \alpha^3 + 1
\alpha^15 = \alpha ^14 * \alpha = \alpha^4 + \alpha = 1

となり、\alpha^15 + 1 = 0




















AESに必要なバイト単位の演算では、$ BF(2) $ の拡大体 $ GF(2^8) $ を使います。GF(2)上で、次の8次の多項式で剰余計算をします。






\alpha^5  = \alpha^4 * \alpha   = \alpha^2 + \alpha
\alpha^8  = (\alpha + 1) ^2     = \alpha^2 + 1





この処理の四則演算は、実数の四則演算とは異なり、有限個の元からなる体で閉じた四則演算です。この四則演算は次の節で説明します。

(x + 1) 根が1。


GF(2)の要素0,1を係数とする多項式。
多項式同士の四則演算は、係数の演算はGF(2)の法則で。
任意の2進数を表現しているようなものだと思えばOK?

掛け算したら1になる数。

拡大体:

拡大体 GF (pm):素体 GF (p)上のひとつの m次原始多項式の
￼￼￼7
根のひとつ ® を GF (p) に加えて体をつくったもの – 原始多項式:
周期がちょうど pm-1の(G(x) | xpm-1 ー 1) m次の多項式 – イメージは実数体 → 虚数体 への拡大
• 実数体上の多項式 x2 +1 = 0 の根のひとつ(i)を実数体に 加え、体となるために必要な元を加えたもの

拡大体の例:
GF (22) を GF (2) の拡大によって構成 GF(2)上の多項式 x2+x+1の根®をGF(2)に付加 0, 1, ® に加え ® のべきは全て含むはず
– ®0 = 1, ®1 = ®, ®2 = ®+1, ®3 = ®2 +® = 1, .... 以下同じもの • ® 2 + ® + 1 = 0 を利用する
–全ての a1®+a0 のパターンが出尽しており加算について閉じている

位数q=p^m(m>1)のガロア体は、modpの加算乗算で構成できない。q=2^2で2の逆元がない。

GF(4)

+ |0 1 2 3
--+--------
0 |0 1 2 3
1 |1 2 3 0
2 |2 3 0 1
3 |3 0 1 2

x |0 1 2 3
--+--------
0 |0 0 0 0
1 |0 1 2 3
2 |0 2 0 2
3 |0 3 2 1

1 / 2 = ?、なにかに2をかけると1になる数、2の列(縦方向の並び)、何を掛けても1にならない。?に当たる数がない。が計算できない。
GF(p)のpは素数じゃないと、演算が閉じない。

GF(p^m)のm次原始多項式。
例えばGF(2)の多項式 x^2+x+1の根αをGF(2)に追加して、
0, 1, α、に加えたら、多項式で x^2+x+1=0で変換できる。

x   |0 1 α α^2
----+--------
0   |
1   |
α   |
α^2 |

べき表現  |      |ベクトル表現
0        | 0    | 0000
1        | 1    | 0001
α        | α    | 0010
α^2      | α^2  | 0100
α^3
